[
    {
        "extension": "ts",
        "code": "// Modifiers for suite and test\ninterface Modifiers {\n  skip?: boolean;\n  timeout?: number;\n  sequence?: boolean;\n  story?: boolean;\n}\n\n// Failure information\ninterface FailureInfo {\n  expected: any;\n  actual: any;\n  context: object;\n}\n\n// Outcome of a test\ntype Outcome = 'success' | 'failure-assertion' | 'failure-exception';\n\n// Single test structure\ninterface Test {\n  name: string;\n  scope: Suite;\n  outcome?: Outcome;\n  failure?: FailureInfo;\n}\n\n// Suite structure\ninterface Suite {\n  name: string;\n  tests: Test[];\n  suites: Suite[];\n  context: ExecutionContext;\n  modifiers: Modifiers;\n}\n\n// Execution context\ninterface ExecutionContext {\n  fail(message: string): void;\n  [key: string]: any; // Additional context variables\n}\n\n// Test run result\ninterface TestRunResult {\n  name: string;\n  successes: number;\n  failures: number;\n  children: TestRunResult[];\n}\n"
    },
    {
        "extension": "ts",
        "code": "type TestFunction = (context: ExecutionContext) => void;\n\nclass TestRunner {\n  static test(name: string, testFunction: TestFunction): TestRunner;\n  static test.skip(name: string, testFunction: TestFunction): TestRunner;\n  static test.timeout(ms: number, name: string, testFunction: TestFunction): TestRunner;\n\n  static suite(name: string, definitionFunction: (suite: SuiteRunner) => void): TestRunner;\n  static suite.sequence(name: string, definitionFunction: (suite: SuiteRunner) => void): TestRunner;\n  static suite.story(name: string, definitionFunction: (suite: SuiteRunner) => void): TestRunner;\n  static suite.skip(name: string, definitionFunction: (suite: SuiteRunner) => void): TestRunner;\n}\n\nclass SuiteRunner {\n  test(name: string, testFunction: TestFunction): SuiteRunner;\n  test.skip(name: string, testFunction: TestFunction): SuiteRunner;\n  test.timeout(ms: number, name: string, testFunction: TestFunction): SuiteRunner;\n\n  suite(name: string, definitionFunction: (suite: SuiteRunner) => void): SuiteRunner;\n  suite.sequence(name: string, definitionFunction: (suite: SuiteRunner) => void): SuiteRunner;\n  suite.story(name: string, definitionFunction: (suite: SuiteRunner) => void): SuiteRunner;\n  suite.skip(name: string, definitionFunction: (suite: SuiteRunner) => void): SuiteRunner;\n}\n"
    },
    {
        "extension": "ts",
        "code": "interface ExecutionContext {\n  fail(message: string): void;\n  [key: string]: any;\n}\n\ninterface RunnableFunction {\n  (context: ExecutionContext, runner: SuiteRunner | TestRunner): void;\n  async (context: ExecutionContext, runner: SuiteRunner): Promise<void>;\n}\n\ninterface RunnableUnit {\n  options: {\n    skip: boolean;\n    timeout: number;\n  };\n\n  (name: string, definitionFunction: RunnableFunction): void;\n\n  skip(name: string, definitionFunction: RunnableFunction): void;\n  timeout(name: string, definitionFunction: RunnableFunction): void;\n}\n\ninterface RunnableSet extends RunnableUnit {\n  options: RunnableUnit['options'] & {\n    sequence: boolean;\n    story: boolean;\n  };\n\n  sequence(name: string, definitionFunction: RunnableFunction): void;\n  story(name: string, definitionFunction: RunnableFunction): void;\n}\n\n// Implementation of test\nconst test: RunnableUnit = {\n  options: {\n    skip: false,\n    timeout: 0,\n  },\n  // TODO: Implement functionality for creating a test\n  skip(name, definitionFunction) {\n    // TODO: Implement skip modifier\n  },\n  timeout(name, definitionFunction) {\n    // TODO: Implement timeout modifier\n  },\n};\n\n// Implementation of suite\nconst suite: RunnableSet = {\n  ...test,\n  options: {\n    ...test.options,\n    sequence: false,\n    story: false,\n  },\n  sequence(name, definitionFunction) {\n    // TODO: Implement sequence modifier\n  },\n  story(name, definitionFunction) {\n    // TODO: Implement story modifier\n  },\n};\n\n// Examples\nsuite('My Suite', (context, runner) => {\n  runner.test('My Test', (context) => {\n    // Test implementation\n  });\n});\n\nsuite.sequence('My Sequential Suite', (context, runner) => {\n  // Suite implementation\n});\n"
    },
    {
        "extension": "ts",
        "code": "type Modifiers = 'skip' | 'timeout' | 'sequence' | 'story';\n\ninterface ExecutionContext {\n  fail(message: string): void;\n  [key: string]: any;\n}\n\ninterface RunnableFunction {\n  (context: ExecutionContext, runner: SuiteRunner | TestRunner): void;\n  async (context: ExecutionContext, runner: SuiteRunner): Promise<void>;\n}\n\nconst createRunnableUnit = (modifiers: Modifiers[]): RunnableUnit => ({\n  options: {\n    skip: false,\n    timeout: 0,\n  },\n  (name: string, definitionFunction: RunnableFunction): void {\n    // TODO: Implement functionality for creating a runnable unit (test or suite)\n  },\n  ...modifiers.reduce((obj, modifier) => {\n    obj[modifier] = (name: string, definitionFunction: RunnableFunction) => {\n      this.options[modifier] = true;\n      this(name, definitionFunction);\n    };\n    return obj;\n  }, {} as Partial<RunnableUnit>)\n});\n\nconst test: RunnableUnit = createRunnableUnit(['skip', 'timeout']);\n\nconst suite: RunnableSet = {\n  ...createRunnableUnit(['skip', 'timeout', 'sequence', 'story']),\n  options: {\n    ...test.options,\n    sequence: false,\n    story: false,\n  },\n};\n\n// Examples\nsuite('My Suite', (context, runner) => {\n  runner.test('My Test', (context) => {\n    // Test implementation\n  });\n});\n\nsuite.sequence('My Sequential Suite', (context, runner) => {\n  // Suite implementation\n});\n"
    },
    {
        "extension": "ts",
        "code": "type TestBlockModifiers = 'skip' | 'timeout' | 'sequence' | 'story';\n\ninterface TestBlockOptions {\n  skip: boolean;\n  timeout: number;\n  sequence?: boolean;\n  story?: boolean;\n}\n\ninterface RunnableFunction {\n  (context: ExecutionContext, runner: SuiteRunner | TestRunner): void;\n  async (context: ExecutionContext, runner: SuiteRunner): Promise<void>;\n}\n\nconst createTestBlock = (modifiers: TestBlockModifiers[], options: TestBlockOptions): RunnableUnit | RunnableSet => ({\n  options,\n  (name: string, definitionFunction: RunnableFunction): void {\n    // TODO: Implement functionality for creating a test block (test or suite)\n  },\n  ...modifiers.reduce((obj, modifier) => {\n    obj[modifier] = (name: string, definitionFunction: RunnableFunction) => {\n      this.options[modifier] = true;\n      this(name, definitionFunction);\n    };\n    return obj;\n  }, {} as Partial<RunnableUnit | RunnableSet>)\n});\n\nconst test: RunnableUnit = createTestBlock(['skip', 'timeout'], { skip: false, timeout: 0 });\n\nconst suite: RunnableSet = createTestBlock(['skip', 'timeout', 'sequence', 'story'], { skip: false, timeout: 0, sequence: false, story: false });\n"
    },
    {
        "extension": "ts",
        "code": "class TestRunner {\n  private currentScope: Suite | null = null;\n  private rootSuites: Suite[] = [];\n\n  public suite(name: string, definitionFunction: RunnableFunction): void {\n    const suite: Suite = {\n      name,\n      scope: this.currentScope,\n      suites: [],\n      tests: [],\n    };\n    if (this.currentScope) {\n      this.currentScope.suites.push(suite);\n    } else {\n      this.rootSuites.push(suite);\n    }\n    const previousScope = this.currentScope;\n    this.currentScope = suite;\n    definitionFunction(this.executionContext, this);\n    this.currentScope = previousScope;\n  }\n\n  public test(name: string, definitionFunction: RunnableFunction): void {\n    const test: Test = {\n      name,\n      scope: this.currentScope,\n    };\n    if (this.currentScope) {\n      this.currentScope.tests.push(test);\n    } else {\n      throw new Error(\"Test must be defined within a suite\");\n    }\n    // Optionally, you may execute the definitionFunction here or store it for later execution\n  }\n\n  // Additional methods for execution and handling modifiers\n}\n\n// Usage\nconst runner = new TestRunner();\nrunner.suite('A', () => {\n  runner.suite('B', () => {\n    runner.test('T', () => { /* Test implementation */ });\n  });\n});\n"
    },
    {
        "extension": "ts",
        "code": "class TestRunner {\n  // ... Previous code ...\n\n  private createExecutionContext(parentContext?: ExecutionContext): ExecutionContext {\n    return {\n      fail: (message: string) => { /* Handle failure */ },\n      ...parentContext, // Inherit from parent context\n    };\n  }\n\n  private runTest(test: Test, context: ExecutionContext): void {\n    if (test.options.skip) return; // Handle skip modifier\n    // TODO: Implement test execution logic, including handling timeouts\n  }\n\n  private runSuite(suite: Suite, context: ExecutionContext): void {\n    if (suite.options.skip) return; // Handle skip modifier\n\n    const suiteContext = this.createExecutionContext(context);\n\n    if (suite.options.sequence) {\n      // Run child suites and tests in sequence\n      for (const childSuite of suite.suites) {\n        this.runSuite(childSuite, suiteContext);\n      }\n      for (const childTest of suite.tests) {\n        this.runTest(childTest, suiteContext);\n      }\n    } else {\n      // TODO: Implement parallel execution of child suites and tests\n    }\n\n    // TODO: Implement \"story\" modifier behavior\n  }\n\n  public run(): void {\n    for (const rootSuite of this.rootSuites) {\n      this.runSuite(rootSuite, this.createExecutionContext());\n    }\n  }\n}\n\n// Usage\nconst runner = new TestRunner();\nrunner.suite('A', () => {\n  runner.suite('B', () => {\n    runner.test('T', () => { /* Test implementation */ });\n  });\n});\nrunner.run(); // Executes the tests\n"
    },
    {
        "extension": "ts",
        "code": "class TestRunner {\n  // ... Previous code ...\n\n  private async runTest(test: Test, context: ExecutionContext): Promise<void> {\n    if (test.options.skip) return; // Handle skip modifier\n\n    try {\n      // TODO: Implement timeout handling\n      await test.definitionFunction(context, this); // Assuming test functions are async\n      test.outcome = 'success';\n    } catch (error) {\n      // TODO: Differentiate between assertion and exception failures\n      test.outcome = 'failure-exception';\n      test.failure = { /* Failure information */ };\n    }\n\n    // TODO: Handle recording of successes and failures\n  }\n\n  private async runSuite(suite: Suite, context: ExecutionContext): Promise<void> {\n    if (suite.options.skip) return; // Handle skip modifier\n\n    const suiteContext = this.createExecutionContext(context);\n\n    const tasks = [];\n\n    for (const childSuite of suite.suites) {\n      tasks.push(this.runSuite(childSuite, suiteContext));\n    }\n    for (const childTest of suite.tests) {\n      tasks.push(this.runTest(childTest, suiteContext));\n    }\n\n    if (suite.options.sequence || suite.options.story) {\n      for (const task of tasks) {\n        await task; // Run tasks in sequence\n        if (suite.options.story && /* TODO: Check for any failures */) {\n          break; // Stop at first failure for story modifier\n        }\n      }\n    } else {\n      await Promise.all(tasks); // Run tasks in parallel\n    }\n  }\n\n  public async run(): Promise<TestRunResult> {\n    const results: TestRunResult[] = [];\n    for (const rootSuite of this.rootSuites) {\n      results.push(await this.runSuite(rootSuite, this.createExecutionContext()));\n    }\n    return { /* Combine results into a hierarchical TestRunResult */ };\n  }\n}\n"
    },
    {
        "extension": "ts",
        "code": "export class Square {\n  constructor(public size: number, public x: number, public y: number) {}\n\n  /**\n   * Splits the square into 4 equal squares covering the same area.\n   * @returns An array of 4 new Square instances.\n   */\n  splitIntoQuarters(): Square[] {\n    const halfSize = this.size / 2;\n    return [\n      new Square(halfSize, this.x, this.y),\n      new Square(halfSize, this.x + halfSize, this.y),\n      new Square(halfSize, this.x, this.y + halfSize),\n      new Square(halfSize, this.x + halfSize, this.y + halfSize),\n    ];\n  }\n}\n"
    },
    {
        "extension": "ts",
        "code": "import { suite, test } from '../path-to-types'; // Replace with the correct path to types\nimport { Square } from './square';\n\nsuite('Square class', () => {\n  test('constructor initializes properties correctly', (context) => {\n    const square = new Square(10, 5, 5);\n    // TODO: Use an assertion library to verify properties\n  });\n\n  suite('splitIntoQuarters method', () => {\n    test('splits the square into 4 equal parts', (context) => {\n      const square = new Square(10, 5, 5);\n      const quarters = square.splitIntoQuarters();\n      // TODO: Use an assertion library to verify the quarters\n    });\n\n    test('maintains the same total area', (context) => {\n      const square = new Square(10, 5, 5);\n      const quarters = square.splitIntoQuarters();\n      // TODO: Use an assertion library to verify the total area\n    });\n  });\n});\n"
    },
    {
        "extension": "ts",
        "code": "import { suite, test } from '../path-to-types'; // Replace with the correct path to types\nimport { Square } from './square';\n\nsuite('Square class', () => {\n  test('constructor initializes properties correctly', (context) => {\n    const square = new Square(10, 5, 5);\n    context.failUnlessEqual(square.size, 10);\n    context.failUnlessEqual(square.x, 5);\n    context.failUnlessEqual(square.y, 5);\n  });\n\n  suite('splitIntoQuarters method', () => {\n    test('splits the square into 4 equal parts', (context) => {\n      const square = new Square(10, 5, 5);\n      const quarters = square.splitIntoQuarters();\n\n      quarters.forEach((quarter) => {\n        context.failUnlessEqual(quarter.size, 5);\n      });\n    });\n\n    test('maintains the same total area', (context) => {\n      const square = new Square(10, 5, 5);\n      const quarters = square.splitIntoQuarters();\n      const totalArea = quarters.reduce((sum, quarter) => sum + quarter.size * quarter.size, 0);\n\n      context.failUnlessEqual(totalArea, square.size * square.size);\n    });\n  });\n});\n"
    },
    {
        "extension": "ts",
        "code": "{\n  \"name\": \"Run, Figma, Run\",\n  \"nickname\": \"RFR\",\n  \"description\": \"A test runner designed to help Figma plugin developers test their code inside the real environment where they will run: a sandboxed thread inside of Figma.\",\n  \"architecture\": {\n    \"figma\": \"Main application where everything runs.\",\n    \"sandboxedThread\": \"Restricted environment inside Figma where the plugin code executes.\",\n    \"rfr\": \"Replaces the main function of the plugin, running the tests.\",\n    \"plugin\": \"Original code that developers write, subject to testing by RFR.\",\n    \"iframe\": \"Contains the plugin UI and is used by RFR to output the test results.\"\n  },\n  \"types\": {\n    \"RunnableFunction\": \"Function representing a test or suite.\",\n    \"RunnableUnit\": \"Object representing a test or suite with options and modifiers.\",\n    \"RunnableSet\": \"Object representing a suite with additional options and modifiers.\",\n    \"ExecutionContext\": \"Object representing the execution context for tests and suites.\"\n  },\n  \"modifiers\": [\"skip\", \"timeout\", \"sequence\", \"story\"],\n  \"code_snippets\": {\n    \"test_runner_class\": \"Code for the TestRunner class, handling registration, execution, modifiers, and results.\",\n    \"examples_square\": \"Code for the Square class, representing a square with size, x, and y, and a method to split into quarters.\",\n    \"examples_square_spec\": \"Code for testing the Square class, including suites and tests to assert its behavior.\"\n  }\n}\n"
    },
    {
        "extension": "ts",
        "code": "{\n  \"name\": \"Run, Figma, Run\",\n  \"nickname\": \"RFR\",\n  \"description\": \"A test runner designed to help Figma plugin developers test their code inside the real environment where they will run: a sandboxed thread inside of Figma.\",\n  \"architecture\": {\n    \"figma\": \"Main application where everything runs.\",\n    \"sandboxedThread\": \"Restricted environment inside Figma where the plugin code executes.\",\n    \"rfr\": \"Replaces the main function of the plugin, running the tests.\",\n    \"plugin\": \"Original code that developers write, subject to testing by RFR.\",\n    \"iframe\": \"Contains the plugin UI and is used by RFR to output the test results.\"\n  },\n  \"types\": {\n    \"RunnableFunction\": \"Function representing a test or suite. Defined in our conversation.\",\n    \"RunnableUnit\": \"Object representing a test or suite with options and modifiers. Defined in our conversation.\",\n    \"RunnableSet\": \"Object representing a suite with additional options and modifiers. Defined in our conversation.\",\n    \"ExecutionContext\": \"Object representing the execution context for tests and suites. Defined in our conversation.\"\n  },\n  \"modifiers\": {\n    \"skip\": \"Skips the execution of the test or suite.\",\n    \"timeout\": \"Overrides the default timeout for the test or suite.\",\n    \"sequence\": \"Runs child suites or tests in order.\",\n    \"story\": \"Runs child suites or tests in order and stops at the first failed test or suite.\"\n  },\n  \"code_snippets\": {\n    \"test_runner_class\": \"Code for the TestRunner class, handling registration, execution, modifiers, and results. Defined in our conversation.\",\n    \"examples_square\": \"Code for the Square class, representing a square with size, x, and y, and a method to split into quarters. Defined in our conversation.\",\n    \"examples_square_spec\": \"Code for testing the Square class, including suites and tests to assert its behavior. Defined in our conversation.\"\n  },\n  \"integration\": \"RFR replaces the main function of the plugin to run tests instead of the actual plugin code, and outputs the results as a single HTML page to Figma in place of the plugin's UI page.\",\n  \"assertion_mechanism\": \"Basic equality checks are used as assertions. In a real-world scenario, a third-party assertion library would be used.\"\n}\n"
    },
    {
        "extension": "ts",
        "code": "{\n  \"name\": \"Run, Figma, Run\",\n  \"nickname\": \"RFR\",\n  \"description\": \"A test runner designed to help Figma plugin developers test their code inside the real environment where they will run: a sandboxed thread inside of Figma.\",\n  \"architecture\": {\n    \"figma\": \"Main application where everything runs.\",\n    \"sandboxedThread\": \"Restricted environment inside Figma where the plugin code executes.\",\n    \"rfr\": \"Replaces the main function of the plugin, running the tests.\",\n    \"plugin\": \"Original code that developers write, subject to testing by RFR.\",\n    \"iframe\": \"Contains the plugin UI and is used by RFR to output the test results.\"\n  },\n  \"types\": {\n    \"RunnableFunction\": \"Function representing a test or suite. Defined in our conversation.\",\n    \"RunnableUnit\": \"Object representing a test or suite with options and modifiers. Defined in our conversation.\",\n    \"RunnableSet\": \"Object representing a suite with additional options and modifiers. Defined in our conversation.\",\n    \"ExecutionContext\": \"Object representing the execution context for tests and suites. Defined in our conversation.\"\n  },\n  \"modifiers\": {\n    \"skip\": \"Skips the execution of the test or suite.\",\n    \"timeout\": \"Overrides the default timeout for the test or suite.\",\n    \"sequence\": \"Runs child suites or tests in order.\",\n    \"story\": \"Runs child suites or tests in order and stops at the first failed test or suite.\"\n  },\n  \"code_snippets\": {\n    \"test_runner_class\": \"Code for the TestRunner class, handling registration, execution, modifiers, and results. Defined in our conversation.\",\n    \"examples_square\": \"Code for the Square class, representing a square with size, x, and y, and a method to split into quarters. Defined in our conversation.\",\n    \"examples_square_spec\": \"Code for testing the Square class, including suites and tests to assert its behavior. Defined in our conversation.\"\n  },\n  \"integration\": {\n    \"description\": \"RFR replaces the main function of the plugin to run tests instead of the actual plugin code, and outputs the results as a single HTML page to Figma in place of the plugin's UI page.\",\n    \"with_bundler\": \"RFR integrates into the bundler (rollup, vite, esbuild, etc). When the build is executed with a env variable TEST_MODE present and not empty, RFR will change the entry point script given to the bundler.\"\n  },\n  \"assertion_mechanism\": \"Basic equality checks are used as assertions. In a real-world scenario, a third-party assertion library would be used.\"\n}\n"
    },
    {
        "extension": "ts",
        "code": "{\n  \"name\": \"Run, Figma, Run\",\n  \"nickname\": \"RFR\",\n  \"language\": \"typescript\",\n  \"project_type\": \"npm package\",\n  \"visibility\": \"public\",\n  \"template\": \"nx standalone app workspace created with `pnpx create-nx-workspace@latest`\",\n  \"ui_framework\": \"none, pure JS, HTML, CSS\",\n  \"license\": \"MIT\",\n  \"folder_structure\": {\n    \"/src\": \"for typescript code\",\n    \"/assets\": \"for static HTML, CSS, and JS\",\n    \"/lib\": \"for output\",\n    \"/tests\": \"for Jest tests\",\n    \"/docs\": \"for the documentation site using Astro\",\n    \"/docs/api\": \"for automatically generate documentation using typedoc or tsdoc\",\n    \"/docs/guides\": \"for the guides on how to use RFR\",\n    \"README.md\": \"for a summary of the documentation\"\n  },\n  \"assets\": [\"results.html\", \"launch and test flow diagram\"],\n  \"missing_types\": \"Define ALL interfaces and types as TypeScript definitions (no implementation)\",\n  \"tools\": [\"git\", \"nx\", \"rollup\"],\n  \"package_manager\": \"pnpm\",\n  \"devDependencies\": [\"nx\", \"@nx/workspace\", \"@nx/js\", \"typescript\", \"prettier\", \"eslint\", \"rollup\", \"jest\"],\n  \"README_sections\": [\n    \"# Run, Figma, Run!\",\n    \"## Tagline\",\n    \"[ description ]\",\n    \"## How it Works\",\n    \"## Code Example\",\n    \"## Installation\",\n    \"### Configuration\",\n    \"## Changelog\",\n    \"## License\",\n    \"## Authors\"\n  ],\n  // ... Rest of the existing content ...\n}\n"
    },
    {
        "extension": "ts",
        "code": "declare namespace RFR {\n  interface ExecutionContext {\n    fail(message: string): void;\n    failUnlessEqual(actual: any, expected: any): void; // Replace with proper assertion method\n  }\n\n  interface RunnableFunction {\n    (context: ExecutionContext): void;\n    async(context: ExecutionContext): Promise<void>;\n  }\n\n  interface RunnableUnit {\n    options: {\n      skip: boolean;\n      timeout: number;\n    };\n    (name: string, definitionFunction: RunnableFunction): void;\n    skip(name: string, definitionFunction: RunnableFunction): void;\n    timeout(name: string, definitionFunction: RunnableFunction): void;\n  }\n\n  interface RunnableSet extends RunnableUnit {\n    options: RunnableUnit['options'] & {\n      sequence: boolean;\n      story: boolean;\n    };\n    sequence(name: string, definitionFunction: RunnableFunction): void;\n    story(name: string, definitionFunction: RunnableFunction): void;\n  }\n\n  interface TestResult {\n    name: string;\n    scope: Suite | TestRunner;\n    outcome: 'success' | 'failure';\n    failure?: {\n      expected: any;\n      actual: any;\n      context: object;\n    };\n  }\n\n  interface Suite {\n    name: string;\n    scope: Suite | TestRunner;\n    tests: TestResult[];\n    suites: Suite[];\n  }\n\n  class TestRunner {\n    // Methods for registration, execution, handling modifiers, and results\n    registerSuite(name: string, definitionFunction: RunnableFunction, options?: object): void;\n    registerTest(name: string, definitionFunction: RunnableFunction, options?: object): void;\n    run(): Promise<TestRunResult>;\n  }\n\n  interface TestRunResult {\n    successes: number;\n    failures: number;\n    results: TestResult[];\n  }\n\n  class Square {\n    constructor(size: number, x: number, y: number);\n    size: number;\n    x: number;\n    y: number;\n    splitIntoQuarters(): Square[];\n  }\n}\n\ndeclare const suite: RFR.RunnableSet;\ndeclare const test: RFR.RunnableUnit;\n"
    },
    {
        "extension": "ts",
        "code": "{\n  \"name\": \"Run, Figma, Run\",\n  \"nickname\": \"RFR\",\n  \"language\": \"typescript\",\n  \"project_type\": \"npm package\",\n  \"visibility\": \"public\",\n  \"template\": \"nx standalone app workspace created with `pnpx create-nx-workspace@latest`\",\n  \"ui_framework\": \"none, pure JS, HTML, CSS\",\n  \"license\": \"MIT\",\n  \"folder_structure\": {\n    \"/src\": \"for typescript code\",\n    \"/assets\": \"for static HTML, CSS, and JS\",\n    \"/lib\": \"for output\",\n    \"/tests\": \"for Jest tests\",\n    \"/docs\": \"for the documentation site using Astro\",\n    \"/docs/api\": \"for automatically generate documentation using typedoc or tsdoc\",\n    \"/docs/guides\": \"for the guides on how to use RFR\",\n    \"README.md\": \"for a summary of the documentation\"\n  },\n  \"assets\": [\"results.html\", \"launch and test flow diagram\"],\n  \"missing_types\": \"Define ALL interfaces and types as TypeScript definitions (no implementation)\",\n  \"tools\": [\"git\", \"nx\", \"rollup\"],\n  \"package_manager\": \"pnpm\",\n  \"devDependencies\": [\"nx\", \"@nx/workspace\", \"@nx/js\", \"typescript\", \"prettier\", \"eslint\", \"rollup\", \"jest\"],\n  \"README_sections\": [\n    \"# Run, Figma, Run!\",\n    \"## Tagline\",\n    \"[ description ]\",\n    \"## How it Works\",\n    \"## Code Example\",\n    \"## Installation\",\n    \"### Configuration\",\n    \"## Changelog\",\n    \"## License\",\n    \"## Authors\"\n  ],\n  \"architecture\": {\n    \"figma\": \"Main application where everything runs.\",\n    \"sandboxedThread\": \"Restricted environment inside Figma where the plugin code executes.\",\n    \"rfr\": \"Replaces the main function of the plugin, running the tests.\",\n    \"plugin\": \"Original code that developers write, subject to testing by RFR.\",\n    \"iframe\": \"Contains the plugin UI and is used by RFR to output the test results.\"\n  },\n  \"types\": {\n    \"RunnableFunction\": \"Function representing a test or suite. Defined in our conversation.\",\n    \"RunnableUnit\": \"Object representing a test or suite with options and modifiers. Defined in our conversation.\",\n    \"RunnableSet\": \"Object representing a suite with additional options and modifiers. Defined in our conversation.\",\n    \"ExecutionContext\": \"Object representing the execution context for tests and suites. Defined in our conversation.\"\n  },\n  \"modifiers\": {\n    \"skip\": \"Skips the execution of the test or suite.\",\n    \"timeout\": \"Overrides the default timeout for the test or suite.\",\n    \"sequence\": \"Runs child suites or tests in order.\",\n    \"story\": \"Runs child suites or tests in order and stops at the first failed test or suite.\"\n  },\n  \"code_snippets\": {\n    \"test_runner_class\": \"Code for the TestRunner class, handling registration, execution, modifiers, and results. Defined in our conversation.\",\n    \"examples_square\": \"Code for the Square class, representing a square with size, x, and y, and a method to split into quarters. Defined in our conversation.\",\n    \"examples_square_spec\": \"Code for testing the Square class, including suites and tests to assert its behavior. Defined in our conversation.\"\n  },\n  \"integration\": {\n    \"description\": \"RFR replaces the main function of the plugin to run tests instead of the actual plugin code, and outputs the results as a single HTML page to Figma in place of the plugin's UI page.\",\n    \"with_bundler\": \"RFR integrates into the bundler (rollup, vite, esbuild, etc). When the build is executed with a env variable TEST_MODE present and not empty, RFR will change the entry point script given to the bundler.\"\n  },\n  \"assertion_mechanism\": \"Basic equality checks are used as assertions. In a real-world scenario, a third-party assertion library would be used.\"\n}\n"
    }
]
